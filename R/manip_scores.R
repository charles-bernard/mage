# mage R package

# This file regroups functions to:
#   1. Compute p-values for the MIC scores
#   1. Filter the matrix based on a threshold of significance
#   2. Standardize the matrix (using zscore)


#' @title assign_pval
#'
#' @description
#' Assigns p-values to MIC scores
#'
#' @param MIC_scores numeric vector of MIC scores
#' @param nb_cells nb of cells in the gene expression matrix
#'
#' @return
#' Returns a vector of p-values
#'
#' @details
#' Since the p-value of a given MIC score cannot be computed
#' by a simple mathemical function, \code{assigns_pval} reads
#' the p-value table generated by the authors of the MINE
#' statistics (see \url{http://www.exploredata.net/Downloads/P-Value-Tables})
#' at the closest \emph{sample_size} to \emph{nb_cells}.
#'
#' For each \emph{MIC score}, \code{assign_pval} will then
#' retrieve the corresponding p-value from this table.
#'
assign_pval <- function(MIC_scores,
                nb_cells) {
  MIC_scores <- round(MIC_scores, 3);

  # Get indexes of each unique value in the MIC score vector
  # ----------------------------------------------------------------------
  uniq_MIC_scores <- unique(MIC_scores);
  uniq_MIC_scores_ix <- list();
  for(i in 1:length(uniq_MIC_scores)) {
    uniq_MIC_scores_ix[[i]] <- which(MIC_scores == uniq_MIC_scores[i]);
  }

  # Get appropriate pval_tab:
  # sample_size must be as close as possible to nb_cells
  # ----------------------------------------------------------------------
  pval_data <- load(system.file("R/sysdata.rda", package = "mage"));
  closest_sample_size_ix <- which.min(abs(as.integer(sample_size) - nb_cells));
  pval_tab <- pval_tables[[closest_sample_size_ix]];
  
  # Print the absolute difference btw nb_cells and sample_size
  # ----------------------------------------------------------------------
  print(sprintf("abs(sample_size - nb_cells) = %d", 
          abs(as.integer(sample_size[closest_sample_size_ix]) - nb_cells)));
  print("If this difference is too big, consider ignoring these p-values ...")
  
  # Get the boundaries of the table
  # ----------------------------------------------------------------------
  pval_tab_max_MIC <- pval_tab[1, 1];
  pval_tab_min_MIC <- pval_tab[nrow(pval_tab), 1];
  most_signif_MIC_ix <- which(uniq_MIC_scores > c(pval_tab_max_MIC));
  least_signif_MIC_ix <- which(uniq_MIC_scores < c(pval_tab_min_MIC));

  # Get the p-value assigned to any MIC written in pval_tab
  # ----------------------------------------------------------------------
  pval_tab_MIC_scores <- round(pval_tab[,1], 3);
  pval_tab_uniq_MIC_scores <- unique(pval_tab_MIC_scores);
  pval_tab_uniq_MIC_scores_pval <- rep(0, length(pval_tab_uniq_MIC_scores));
  for(i in 1:length(pval_tab_uniq_MIC_scores)) {
    pval_tab_uniq_MIC_scores_pval[i] <-
      round(pval_tab[which(pval_tab_MIC_scores == pval_tab_uniq_MIC_scores[i])[1], 2], 3);
  }
  pval_tab_uniq_MIC_scores_pval <- unlist(pval_tab_uniq_MIC_scores_pval);

  # Use these references to assign a p-value to each MIC score
  # present in the MIC_scores vector
  # ----------------------------------------------------------------------
  p_values <- rep(1, length(MIC_scores)); # Any unassigned MIC will have a p-value of 1
  first_i = length(most_signif_MIC_ix) + 1;
  last_i = length(uniq_MIC_scores) - length(least_signif_MIC_ix) + 1;
  for(i in first_i:last_i) {
    cur_ix <- which.min(
      abs(pval_tab_uniq_MIC_scores
          - uniq_MIC_scores[i]));
    p_values[uniq_MIC_scores_ix[[i]]] <- pval_tab_uniq_MIC_scores_pval[cur_ix];
  }

  # Assign p-value = 0 to any MIC > max(MIC) present in pval_tab
  # ----------------------------------------------------------------------
  for(i in 1:length(most_signif_MIC_ix)) {
    p_values[uniq_MIC_scores_ix[[most_signif_MIC_ix[i]]]] <- 0;
  }

  return(p_values);
}

#' @title adjust_pval
#'
#' @description
#' Adjust p-values using FDR method (Benjamini & Hochberg, 1995)
#'
#' @param pval numeric vector of p-values
#'
#' @return
#' Returns a numeric vector of adjusted p-values
#'
adjust_pval <- function(pval) {
  adjusted_pval <- stats::p.adjust(pval, method = "BH");
  return(adjusted_pval);
}

#' @title filter_scores
#'
#' @description
#' Filters a table of scores based on a threshold of significance defined either by a MIC score, or by a p-value
#'
#' @param x data.frame, table of scores
#' @param on variable used for the threshold (accepts only \code{"MIC"} or \code{"pval"})
#' @param pval numeric vector of p-values corresponding to the MIC scores in \code{x} (only if \code{on = "pval"})
#' @param thresh value of the threshold
#'
#' @return
#' Returns a filtered table of scores
#'
#' @examples
#' \dontrun{
#' scores_tab <- compute_scores(my_gene_exp_matrix, n.cores = 6)
#' pvalues <- assign_pval(scores_tab$`MIC (strength)`, nb_cells = 96)
#' signif_scores_tab <- filter_scores(scores_tab, on = "pval", 
#'                                    pval = pvalues, threshold = 0.05)
#' }                                    
#'
#' @details
#' if \code{on = "MIC"}, \code{filter_scores} will retain any association whose MIC >= \code{threshold}
#' 
#' else if \code{on = "pval"}, \code{filter_scores} will retain any association whose p-value <= \code{threshold}
#'   
filter_scores <- function(x,
                   on = 'MIC',
                   pval = NULL,
                   thresh = 0.4) {
  # To do: check all conditions
  
  if(on == "MIC") {
    if(thresh < 0 || thresh > 1) {
      stop("A MIC score is defined in [0;1]");
    }
    retained_ix <- which(x[, 3] >= thresh);
  } else if(on == "pval") {
    if(is.null(pval)) {
      stop("argument pval missing");
    }
    if(length(pval) != nrow(x)) {
      stop("length(pval) must be equal to nrow(x)");
    }
    retained_ix <- which(pval <= thresh);
  } else {
    stop("on argument must be set to either \"MIC\" or \"pval\"");
  }
  
  return(x[retained_ix, ]);
}

#' @title standardize_scores
#'
#' @description
#' Standardize each column of the table of scores via the Zscore: \deqn{x = ( x - mean(column) ) / ( std(column) )}
#'
#' @param x data.frame, table of scores
#' 
#' @return
#' returns a standardized table of scores
standardize_scores <- function(x) {
  std_x <- data.frame(scale(x[, 3:ncol(x)]));
  
  possible_NA_col <- apply(std_x, 2, function(i) any(is.na(i)));
  if(length(which(possible_NA_col == TRUE)) > 0) {
    std_x <- std_x[, -(which(possible_NA_col == TRUE))];
  }
  
  return(data.frame(x[, 1:2], std_x));
}


# file <- "/media/charles/Seagate Expansion Drive/Curie/Analyses/Analyses_CDD/MAGE/A471/794_remaining_mvg/794vg_Mage_out/1-Association_Scores/0-scores.csv";
# data <- fread(file, sep = ",", header = T);
# MIC_scores <- data[,3][[1]];
# nb_cells <- 96;


